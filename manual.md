Отлично, я изучил доработанный черновик и ваши пометки. Я полностью понимаю задачу: необходимо расширить указанные разделы, сохранив при этом стиль и техническую грамотность документа.

Вот итоговый вариант руководства, в котором я раскрыл все ваши заметки, добавил требуемые пояснения и примеры, а также переформатировал Приложение А в соответствии с вашими пожеланиями.

***

# Руководство по API PyScriptManager

Добро пожаловать в руководство по программному интерфейсу приложения (API) PyScriptManager.
 Этот документ предназначен для разработчиков и продвинутых пользователей, которые хотят создавать скрипты, глубоко интегрированные со средой выполнения PySM.

#### Основные понятия (Глоссарий)
Прежде чем двигаться дальше, давайте определимся с ключевыми терминами, которые используются в приложении и этом руководстве.

*   **Приложение** — сама программа "Менеджер Python-скриптов" с графическим интерфейсом.
*   **Корневая директория (папка) (Script Root)** — папка в файловой системе, указанная пользователем как источник для поиска скриптов.
*   **Скрипт** — самодостаточная единица автоматизации, представленная в виде Папки-скрипта.
*   **Папка-скрипт** — директория внутри Корневой директории, содержащая исполняемый файл `run_<имя_папки>.py` и, опционально, файл-паспорт `script_passport.json`.
*   **Паспорт скрипта (`script_passport.json`)** — конфигурационный JSON-файл, описывающий метаданные Скрипта (описание, автор, аргументы командной строки).
*   **Категория** — папка внутри Корневой директории, не являющаяся Скриптом и служащая для иерархической группировки других Скриптов или Категорий.
*   **Дерево доступных скриптов** — иерархическое представление в GUI всех найденных Скриптов и Категорий.
*   **Коллекция (`.pysmc`)** — основной рабочий проект пользователя в формате JSON. Содержит в себе настройки, структуру Наборов и Папок, а также Контекст.
*   **Набор (Set)** — упорядоченная последовательность Экземпляров скриптов, предназначенная для решения комплексной задачи.
*   **Экземпляр скрипта (Instance)** — уникальная копия Скрипта, добавленная в Набор, со своим собственным именем и набором значений аргументов.
*   **Контекст Коллекции** — набор именованных переменных (ключ-значение), хранящийся вместе с Коллекцией и доступный всем Скриптам во время выполнения Набора для обмена данными.

***

## Глава 1: Введение в API PyScriptManager

### 1.1. Что такое API PyScriptManager и для чего он нужен?

**PyScriptManager (PySM)** — это приложение для удобной организации, настройки и запуска Python-скриптов. Его ключевая особенность заключается в том, что оно может работать с вашими скриптами на двух уровнях:

1.  **Простой запуск**: Вы можете взять **практически любой существующий Python-скрипт** и запустить его с помощью PySM без каких-либо изменений в коде. Приложение, если нужно, передаст вашему скрипту аргументы командной строки и запустит его. Это быстро, удобно и очень просто! Но это лишь верхушка айсберга.

2.  **Глубокая интеграция через API**: Настоящая мощь PySM раскрывается при использовании его API. Это небольшой, но очень функциональный набор инструментов, который позволяет вашим скриптам "общаться" с приложением и другими скриптами Python.

Использование API превращает набор независимых скриптов в единую, слаженную систему автоматизации. Вы сможете:
*   Передавать сложные данные (списки, словари) между скриптами.
*   Строить нелинейные, ветвящиеся сценарии выполнения.
*   "Прозрачно" сообщать о прогрессе выполнения в интерфейс PySM.
*   Работать с файлами, не беспокоясь об абсолютных путях.
*   **Интегрироваться с Adobe Photoshop** для чтения метаданных из изображений.
*   И многое другое.

### 1.2. Основные принципы: как скрипт общается с приложением

Когда PySM запускает ваш скрипт, он делает это в **изолированном процессе**. Это значит, что скрипты не могут напрямую обмениваться данными между собой через переменные в памяти.

Общение происходит через специальный **файл контекста** (`*.context.json`), который PySM создает для каждой коллекции скриптов. Этот файл — общая "доска объявлений" для всех скриптов. Один скрипт может записать на нее сообщение (данные), а следующий — прочитать.

Вам, как разработчику скрипта, **не нужно работать с этим файлом напрямую**. Для этого и существует API.

### 1.3. Знакомство с `pysm_context` — вашим главным инструментом

Ключевым элементом API является глобальный объект `pysm_context`. Чтобы получить доступ ко всем возможностям API, вам достаточно импортировать его в начале вашего скрипта.
Этот объект — ваша единственная точка входа. Через его методы вы будете читать и записывать данные, управлять потоком выполнения и использовать другие функции API.

**Простой вариант:**
```python
# 1. Блок: Импорт контекста
from pysm_lib import pysm_context
```

**Рекомендованный вариант:**
Используйте конструкцию `try...except ImportError` в начале вашего скрипта. Это позволит создать флаг `IS_MANAGED_RUN`, который можно использовать для условного выполнения кода, зависящего от API.

```python
# Эта переменная будет истинной только при запуске через PySM
IS_MANAGED_RUN = False

try:
    # Попытка импорта ключевых компонентов API
    from pysm_lib import pysm_context
    from pysm_lib.pysm_context import ConfigResolver
    IS_MANAGED_RUN = True
except ImportError:
    # Этот блок выполнится при прямом запуске скрипта,
    # когда пакет pysm_lib недоступен.
    # Создаем заглушки, чтобы избежать ошибок NameError далее по коду.
    pysm_context = None
    ConfigResolver = None
```
Такой подход обеспечивает универсальность вашего скрипта. Он сохраняет работоспособность в любой среде, а функциональность, специфичная для PySM, активируется автоматически при запуске через менеджер.

### 1.4. Настройка первого скрипта: "Hello!" в среде PySM

Давайте создадим простейший скрипт, чтобы убедиться, что все работает.

1.  Создайте в одной из корневых директорий папку для вашего скрипта, например, `hello_pysm`.
2.  Внутри создайте файл `run_hello_pysm.py` со следующим содержимым:

```python
# run_hello_pysm.py

# 1. Блок: Импортируем API
from pysm_lib import pysm_context

# 2. Блок: Основная логика
def main():
   
    # Получим информацию о запущенном экземпляре скрипта из контекста
    pysm_info = pysm_context.get("var_Hello")
    
    print(f"{pysm_info}")

if __name__ == "__main__":
    main()
```
3. В той же папке создайте файл паспорта `script_passport.json`:

> **Примечание:** Паспорт можно создать и отредактировать гораздо удобнее прямо в интерфейсе PySM.
Для этого достаточно:
- дважды щелкнуть по скрипту в списке доступных скриптов,
- в появившемся диалоговом окне  выбрать вкладку **Аргументы**,
- нажать кнопку **Сканировать файл...**. 
 Поэтому вручную создавать Паспорт скрипта вы будете крайне редко.

```json
{
  "description": "Мой первый скрипт, использующий API PySM. Он выводит приветствие и информацию о наборе.",
  "author": "Ваше Имя",
  "version": "1.0.0"
}
```

Теперь добавьте директорию, содержащую папку `hello_pysm`, в качестве корневой директории скриптов в PySM, обновите список, и вы увидите ваш новый скрипт. Добавьте его в любой набор вашей коллекции скриптов и запустите. 
В консоли вы увидите результат его работы.

---

## Глава 2: Работа с данными (Контекст выполнения)

Контекст — это хранилище данных, общее для всех экземпляров скриптов текущей коллекции. Он состоит из **переменных коллекции**, которые вы можете определить в "Паспорте коллекции", и **динамических переменных**, которые скрипты создают во время работы.

### 2.1. Запись данных в контекст: `pysm_context.set()`

Метод **pysm_context.set** - это основной способ для сохранения или обновления любой переменной в контексте. Такой метод часто называют "сеттер"

```python
# 1. Блок: Импорт
from pysm_lib import pysm_context

# Сохраним к контекст несколько переменных, которые будут использоваться в следующих примерах
# 2. Блок: Простые переменный различных типов данных
pysm_context.set("test_user_name", "Андрей")
pysm_context.set("test_processed_files_count", 150)
pysm_context.set("test_is_successful", True)
pysm_context.set("test_source_folder", "source_images")
pysm_context.set("test_output_dir", "D:/results")
pysm_context.set("test_image_name", "IMG_1234")
pysm_context.set("test_timestamp", "2024-05-20")

# 3. Блок: Более сложные переменные
user_data = {
    "name": "Андрей",
    "login": "andrey_p",
    "address": {
        "city": "Москва",
        "zip": "123456"
    },
    "roles": ["admin", "photographer"]
}
pysm_context.set("test_user_profile", user_data)
pysm_context.set("test_file_list", ["file1.jpg", "file2.jpg"])


print("Все данные были сохранены в контекст.")
```

**Нюансы:**
*   **Группировка переменных:** Хорошей практикой является использование префиксов в имени переменных (например, `photo_`, `db_`). Переменные с одинаковым префиксом группируются и визуально выделяются в редакторе контекста в "Паспорте коллекции", что делает управление ими намного удобнее.
*   Если переменной с таким именем не существует, `set()` создаст ее.
*   Если переменная уже существует, `set()` обновит ее значение.
*   PySM автоматически определяет тип данных (строка, число, список и т.д.).
*   Если вы попытаетесь изменить переменную, помеченную в интерфейсе как "Только чтение" (`read_only`), в консоли появится предупреждение, но выполнение скрипта не прервется.

### 2.2. Чтение данных из контекста: `pysm_context.get()`

Метод **pysm_context.get** - это основной способ извлечь значение переменной их контекста. Такой метод часто называют "геттер"

```python
# 1. Блок: Импорт
from pysm_lib import pysm_context

# 2. Блок: Чтение данных с указанием значения по умолчанию
user_name = pysm_context.get("test_user_name", default="Незнакомец")
processed_files = pysm_context.get("test_processed_files_count", default=0)

print(f"Привет, {user_name}!")
print(f"Обработано файлов: {processed_files}")
```

**Нюансы:**
*   Всегда указывайте параметр `default`. Если переменная по какой-то причине отсутствует в контексте, ваш скрипт не упадет с ошибкой, а будет использовать значение по умолчанию. Это делает код более надежным.

### 2.3. Продвинутое чтение: `get_structured()`

Еще один метод для извлечения данных из контекста. Но в отличии от **pysm_context.get**, этот метод позволяет удобно работать с данными любой сложности: списки, словари и т.д. 
Для доступа к вложенным значениям, просто используйте используйте `get_structured()` с точечной нотацией.

```python
# reader_script.py
from pysm_lib import pysm_context

# Читаем вложенные данные, используя точечную нотацию
city = pysm_context.get_structured("test_user_profile.address.city", default="Неизвестно")
# Этот вызов равносилен user_profile['address']['city']
print(f"Город пользователя: {city}")

# Если ключ не найден, вернется значение по умолчанию
street = pysm_context.get_structured("test_user_profile.address.street", default="Улица не указана")
print(f"Улица: {street}")
```

Этот метод избавляет вас от необходимости проверять наличие каждого ключа вручную, предотвращая ошибки `KeyError` и `TypeError`.

### 2.4. Массовое обновление и удаление

*   **`update(my_dict)`**: Обновляет сразу несколько переменных из словаря.
*   **`remove("my_var")`** или **`remove(["var1", "var2"])`**: Удаляет одну или несколько переменных.
*   **`remove()`**: Вызов без аргументов удаляет **все** пользовательские переменные из контекста, оставляя только системные. Используйте с осторожностью!

### **Практическое задание 1: "Знакомство"**

1.  **Создайте Скрипт А ("asker.py")**. Он должен:
    *   Запросить у пользователя его имя с помощью `input()`.
    *   Сохранить введенное имя в контекст под ключом `current_user_name`.
2.  **Создайте Скрипт Б ("greeter.py")**. Он должен:
    *   Прочитать значение из контекста по ключу `current_user_name`.
    *   Вывести в консоль "Здравствуйте, [имя]!". Если имя не найдено, должно быть выведено "Здравствуйте, аноним!".
3.  **Создайте в PySM набор**, где сначала выполняется Скрипт А, а затем Скрипт Б. Запустите и проверьте результат.

---

## Глава 3: Работа с файлами и путями

Одна из частых проблем при написании скриптов — работа с путями к файлам. Если вы используете абсолютные пути (например, `C:\Users\User\Desktop\photo`), ваш скрипт скорее всего не будет работать на другом компьютере. API PySM решает эту проблему.

### 3.1. `pysm_context.resolve_path()`: делаем скрипты переносимыми

Этот метод преобразует относительный путь в абсолютный. Но делает он это "умно": базовой точкой отсчета является **директория, в которой сохранена ваша коллекция (`.pysmc` файл)**.

Представьте, что ваша коллекция лежит в `D:\MyProjects\PhotoProcessing\MyCollection.pysmc`. А рядом папка с исходниками `D:\MyProjects\PhotoProcessing\source_images`.

```python
from pysm_lib import pysm_context
import os

# Получаем относительный путь из контекста (был задан в примере 2.1)
relative_path = pysm_context.get("test_source_folder")

# Преобразуем его в полный, безопасный путь
if relative_path:
    absolute_path = pysm_context.resolve_path(relative_path)
    # absolute_path будет равен 'D:\\MyProjects\\PhotoProcessing\\source_images'
    
    print(f"Относительный путь к папке: {relative_path}")
    print(f"Абсолютный путь к папке: {absolute_path}")
    print(f"Существует ли папка? {os.path.exists(absolute_path)}")
```

Теперь вы можете переместить всю папку `MyProjects` в любое место, и скрипт продолжит работать, так как он отталкивается от местоположения файла коллекции.

### 3.2. `pysm_context.resolve_template()`: шаблонизация путей

Еще более мощный инструмент — `resolve_template()`. Он заменяет в строке плейсхолдеры `{имя_переменной}` на их значения из контекста.

```python
from pysm_lib import pysm_context

# Используем переменные, заданные в примере 2.1:
# "test_output_dir": "D:/results"
# "test_image_name": "IMG_1234"
# "test_timestamp": "2024-05-20"

# Создаем шаблон пути
path_template = "{test_output_dir}/{test_timestamp}_{test_image_name}.jpg"

# Превращаем шаблон в реальный путь
resolved_path = pysm_context.resolve_template(path_template)
# resolved_path будет "D:/results/2024-05-20_IMG_1234.jpg"

print(f"Используется шаблон: {path_template}")
print(f"Итоговый путь к файлу: {resolved_path}")
```
Этот метод идеально подходит для динамического формирования имен выходных файлов.

### **Практическое задание 2: "Файловый менеджер"**

1.  В **Паспорте коллекции** создайте две переменные контекста:
    *   `source_dir` (тип `string`), значение: `input_data`
    *   `output_file` (тип `string`), значение: `result.txt`
2.  Рядом с файлом `.pysmc` создайте папку `input_data`.
3.  Напишите **один скрипт**, который:
    *   Получает `source_dir` и `output_file` из контекста.
    *   Используя `resolve_path()` и `os.path.join` (или `pathlib`), формирует полный путь к `result.txt` внутри папки `input_data`.
    *   Записывает в этот файл строку "Обработка завершена.".
4.  Запустите набор и убедитесь, что файл `result.txt` появился в папке `input_data`.

---

## Глава 4: Управление последовательностью выполнения

Это одна из самых продвинутых возможностей API. По умолчанию скрипты в наборе выполняются строго по порядку. 
Но в режиме выполнения **"Условный (авто)"** и **"Условный (пошагово)"** скрипт может сам решать, какой скрипт запустить следующим.

### 4.1. Метод `pysm_context.set_next_script()`

Этот метод позволяет вашему скрипту указать, какой из экземпляров в наборе должен быть запущен после завершения текущего.

**Важно**: Метод принимает не имя скрипта, а **ID экземпляра**. Каждый скрипт, добавленный в набор, получает уникальный идентификатор `instance_id`.

### 4.2. Как узнать ID нужного экземпляра? `pysm_context.list_instances()`

Чтобы сделать условный переход осмысленным, ваш скрипт должен знать, из каких экземпляров он может выбирать. 
Метод `list_instances()` возвращает список всех экземпляров в текущем наборе.

Каждый элемент списка — это словарь вида: `{'id': 'instance_id_123', 'name': 'Имя экземпляра'}`.

> **Совет:** Увидеть `instance_id` можно и в графическом интерфейсе PySM. Наведите курсор на экземпляр скрипта в дереве коллекции — во всплывающей подсказке будет указан его ID.

```python
# 1. Блок: Импорт
from pysm_lib import pysm_context
import os

# 2. Блок: Получаем список всех экземпляров в наборе
all_instances = pysm_context.list_instances()

# 3. Блок: Находим ID нужного нам экземпляра по его имени
# Допустим, мы ищем экземпляр с именем "hello_pysm"
target_instance_id = None
script_name_to_find = "hello_pysm"
for instance in all_instances:
    if instance.get("name") == script_name_to_find:
        target_instance_id = instance.get("id")
        break

# 4. Блок: Делаем условный переход
file_to_check = pysm_context.resolve_path("data.csv") # Проверяем файл рядом с коллекцией

if os.path.exists(file_to_check):
    if target_instance_id:
        print(f"Файл найден. Следующим будет выполнен скрипт '{script_name_to_find}' (ID: {target_instance_id}).")
        pysm_context.set_next_script(target_instance_id)
else:
    print("Файл не найден. Выполнение продолжится по стандартной схеме (следующий по списку).")
```

### **Практическое задание 3: "Развилка"**

1.  Создайте три простых скрипта: `checker.py`, `success.py`, `failure.py`. Каждый из них должен просто выводить свое имя в консоль.
2.  В PySM создайте набор и добавьте в него эти три скрипта. **Переименуйте экземпляры** в дереве коллекции:
    *   `checker.py` -> "Проверяющий"
    *   `success.py` -> "Обработка Успех"
    *   `failure.py` -> "Обработка Провал"
3.  Модифицируйте скрипт **`checker.py`**:
    *   Он должен проверять наличие файла `trigger.txt` в папке с коллекцией.
    *   Использовать `list_instances()` для поиска ID экземпляров "Обработка Успех" и "Обработка Провал".
    *   Если файл `trigger.txt` существует, вызвать `set_next_script()` с ID экземпляра "Обработка Успех".
    *   Если файла нет, вызвать `set_next_script()` с ID экземпляра "Обработка Провал".
4.  Установите режим запуска набора в **"Условный (авто)"**.
5.  Запустите набор. Затем создайте пустой файл `trigger.txt` рядом с `.pysmc` и запустите снова. Убедитесь, что поток выполнения меняется.

---

## Глава 5: Интеграция с Adobe Photoshop

PySM предоставляет встроенную функцию для извлечения XMP-метаданных из файлов, поддерживаемых Photoshop (PSD, JPG, TIFF и т.д.). Это особенно полезно для автоматизации в сфере фотографии.

### 5.1. Обзор `pysm_context.get_document_metadata()`

Эта функция подключается к запущенному приложению Adobe Photoshop, открывает указанный документ, считывает его метаданные, записывает их в контекст и закрывает документ без сохранения.

```python
# 1. Блок: Импорт
from pysm_lib import pysm_context

# 2. Блок: Путь к файлу получаем из контекста
psd_path = pysm_context.get("source_psd_path")

if not psd_path:
    print("Ошибка: путь к PSD файлу не указан в контексте.")
else:
    try:
        # 3. Блок: Вызов функции для извлечения всех метаданных
        # Результаты будут записаны в контекст как переменные
        # с префиксом 'psd_meta_' (например, psd_meta_Keywords)
        extracted_data = pysm_context.get_document_metadata(
            doc_path=psd_path,
            fields="__all__", # Указываем, что нужны все поддерживаемые поля
            prefix="psd_meta_"
        )
        
        if extracted_data:
            print("Метаданные успешно извлечены и записаны в контекст.")
            print("Извлеченные данные:", extracted_data)
        else:
            print("В файле не найдено XMP метаданных.")

    except FileNotFoundError:
        print(f"Ошибка: Файл не найден по пути {psd_path}")
    except RuntimeError as e:
        print(f"Критическая ошибка: {e}. Убедитесь, что Adobe Photoshop запущен.")

```

### 5.2. Параметры функции

*   `doc_path` (str): Абсолютный путь к файлу.
*   `fields` (list или str): Список полей для извлечения. Можно передать `['Keywords', 'Description']` или строку `"__all__"` для извлечения всех поддерживаемых полей.
*   `prefix` (str, по умолч. `"psd_meta_"`): Префикс, который будет добавлен к именам переменных, создаваемых в контексте.
*   `clear_before_write` (bool, по умолч. `False`): Если `True`, то перед записью новых данных из контекста будут удалены все переменные с указанным префиксом.

### 5.3. Поддерживаемые поля

Вы можете получить полный список поддерживаемых полей, вызвав `pysm_context.get_available_metadata_fields()`. Основные поля включают: `Keywords`, `Description`, `Rating`, `Label`, `Creator`, `Copyright`, `City`, `Country` и другие.

### **Практическое задание 4: "Экспортер метаданных"**

1.  Создайте в **Паспорте коллекции** переменную `target_psd_file` с путем к любому вашему PSD или JPG файлу с метаданными.
2.  Напишите скрипт, который:
    *   Читает путь из `target_psd_file`.
    *   Использует `get_document_metadata()` для извлечения только полей `Keywords` и `Description`.
    *   Создает рядом с исходным файлом текстовый файл с тем же именем, но расширением `.txt`.
    *   Записывает в этот `.txt` файл извлеченные ключевые слова и описание.

---

## Глава 6: Отображение прогресса выполнения

Сообщать о прогрессе длительных операций — хорошая практика. API PySM делает это невероятно простым благодаря "прозрачной" интеграции с популярной библиотекой **`tqdm`**.

### 6.1. Волшебство `tqdm`

Вам **не нужно изучать новый API**. Когда ваш скрипт запускается под управлением PySM, приложение "на лету" подменяет стандартную библиотеку `tqdm` своей реализацией. Эта реализация вместо отрисовки прогресс-бара в консоли отправляет JSON-сообщения о прогрессе в основной интерфейс PySM, где они и отображаются.

Если же ваш скрипт запускается автономно (не из PySM), он будет использовать настоящую библиотеку `tqdm` и рисовать прогресс-бар в терминале, как обычно.

### 6.2. Пример использования

Просто используйте `tqdm` так, как вы бы делали это в любом другом скрипте.

```python
# 1. Блок: Импорт
import time
from pysm_lib.pysm_progress_reporter import tqdm # или просто "from tqdm import tqdm"

# 2. Блок: Создаем список для обработки
my_files = [f"file_{i}.jpg" for i in range(100)]

# 3. Блок: Оборачиваем итерируемый объект в tqdm
# PySM автоматически перехватит это и покажет прогресс-бар в GUI
for file in tqdm(my_files, desc="Обработка изображений"):
    # Имитация долгой работы
    time.sleep(0.05)

print("Все файлы обработаны!")
```
**Важно:** Для корректной работы перехвата, рекомендуется использовать импорт:
`from pysm_lib.pysm_progress_reporter import tqdm`
Или, если вы хотите, чтобы скрипт работал и вне PySM, установите `tqdm` (`pip install tqdm`) и используйте стандартный `from tqdm import tqdm`.

### **Практическое задание 5: "Терпеливый обработчик"**

1.  Возьмите скрипт из **Практического задания 4**.
2.  Добавьте в него цикл `for`, который будет имитировать обработку 50 файлов.
3.  Оберните этот цикл в `tqdm` с описанием "Извлечение метаданных".
4.  Внутри цикла вызов `get_document_metadata` можно закомментировать, оставив только небольшую паузу `time.sleep(0.1)`, чтобы симулировать работу.
5.  Запустите скрипт и наблюдайте за прогресс-баром в интерфейсе PySM.

---

## Приложение А: Справочник по API `pysm_context`

Здесь представлено краткое формальное описание публичных методов объекта `pysm_context`.

*   **`get(key: str, default: Any = None) -> Any`**
    *   _Описание:_ Получает значение переменной из контекста.
    *   _Параметры:_
        *   `key` (str): Имя (ключ) переменной.
        *   `default` (Any): Значение, которое вернется, если ключ не найден. По умолчанию `None`.
    *   _Возвращает:_ Значение переменной или значение `default`.

*   **`set(key: str, value: Any) -> None`**
    *   _Описание:_ Устанавливает значение переменной. Создает новую, если она не существует, или обновляет существующую.
    *   _Параметры:_
        *   `key` (str): Имя (ключ) переменной.
        *   `value` (Any): Сохраняемое значение.
    *   _Возвращает:_ `None`.

*   **`get_structured(key: str, default: Any = None) -> Any`**
    *   _Описание:_ Получает вложенное значение из словаря (JSON-объекта), хранящегося в контексте, используя точечную нотацию.
    *   _Параметры:_
        *   `key` (str): Путь к значению, например, `'user.address.city'`.
        *   `default` (Any): Значение по умолчанию, если какой-либо из ключей в пути отсутствует.
    *   _Возвращает:_ Вложенное значение или `default`.

*   **`update(update_dict: Dict[str, Any]) -> None`**
    *   _Описание:_ Обновляет несколько переменных в контексте за один вызов, используя данные из словаря.
    *   _Параметры:_
        *   `update_dict` (dict): Словарь, где ключи - имена переменных, а значения - их новые значения.
    *   _Возвращает:_ `None`.

*   **`remove(keys_to_remove: Union[str, List[str], None] = None) -> None`**
    *   _Описание:_ Удаляет переменные из контекста.
    *   _Параметры:_
        *   `keys_to_remove`: Может быть строкой (имя одной переменной), списком строк (несколько переменных) или `None` (удаляет все пользовательские переменные).
    *   _Возвращает:_ `None`.

*   **`get_all() -> Dict[str, Any]`**
    *   _Описание:_ Возвращает словарь, содержащий все переменные контекста и их значения.
    *   _Возвращает:_ `Dict[str, Any]`.

*   **`resolve_path(path_str: str) -> pathlib.Path`**
    *   _Описание:_ Преобразует относительный путь (относительно файла коллекции) в абсолютный объект `pathlib.Path`.
    *   _Параметры:_
        *   `path_str` (str): Строка с относительным или абсолютным путем.
    *   _Возвращает:_ Объект `pathlib.Path` с разрешенным абсолютным путем.

*   **`resolve_template(template_string: str) -> str`**
    *   _Описание:_ Заменяет плейсхолдеры вида `{имя_переменной}` в строке на соответствующие значения из контекста.
    *   _Параметры:_
        *   `template_string` (str): Строка с плейсхолдерами.
    *   _Возвращает:_ Отформатированную строку.

*   **`list_instances() -> List[Dict[str, str]]`**
    *   _Описание:_ Возвращает список всех экземпляров скриптов в текущем наборе, что полезно для условных переходов.
    *   _Возвращает:_ Список словарей, где каждый словарь имеет ключи `'id'` и `'name'`.

*   **`set_next_script(instance_id: str) -> None`**
    *   _Описание:_ Указывает, какой экземпляр скрипта должен быть запущен следующим, переопределяя стандартную последовательность. Работает только в "условных" режимах запуска.
    *   _Параметры:_
        *   `instance_id` (str): Уникальный идентификатор экземпляра, который нужно запустить.
    *   _Возвращает:_ `None`.

*   **`get_document_metadata(...) -> Dict[str, Any]`**
    *   _Описание:_ Извлекает XMP-метаданные из файла через Adobe Photoshop.
    *   _Параметры:_ См. Главу 5.
    *   _Возвращает:_ Словарь с извлеченными данными.

*   **`get_available_metadata_fields() -> List[str]`**
    *   _Описание:_ Возвращает список имен полей метаданных, которые поддерживает `get_document_metadata`.
    *   _Возвращает:_ `List[str]`.

---

## Приложение Б: Продвинутое использование с `ConfigResolver`

`ConfigResolver` — это вспомогательный класс для создания скриптов, которые могут работать как под управлением PySM, так и полностью автономно из командной строки. Он "умно" получает значения для аргументов, соблюдая следующий приоритет:

1.  **Аргумент, переданный в командной строке** (высший приоритет).
2.  **Переменная из контекста PySM**.
3.  **Значение по умолчанию**, указанное при определении аргумента в `argparse`.

**Пример скрипта двойного назначения:**

```python
# dual_purpose_script.py

import argparse

# Эта переменная будет истинной только при запуске через PySM
IS_MANAGED_RUN = False

try:
    # Попытка импорта ключевых компонентов API
    from pysm_lib import pysm_context
    from pysm_lib.pysm_context import ConfigResolver
    IS_MANAGED_RUN = True
except ImportError:
    # Этот блок выполнится при прямом запуске скрипта,
    # когда пакет pysm_lib недоступен.
    # Создаем заглушки, чтобы избежать ошибок NameError далее по коду.
    pysm_context = None
    ConfigResolver = None


# 1. Определяем аргументы как обычно с помощью argparse
parser = argparse.ArgumentParser(description="Скрипт двойного назначения.")
parser.add_argument("--input-file", type=str, required=True, help="Входной файл.")
parser.add_argument("--mode", type=str, default="fast", choices=["fast", "slow"], help="Режим обработки.")

# 2. Создаем ConfigResolver
resolver = ConfigResolver(parser)

# 3. Разрешаем все аргументы
# Это можно делать для каждого аргумента отдельно с resolver.get('input_file')
# или для всех сразу:
config = resolver.resolve_all()

# 4. Используем полученные значения
print(f"--- Запуск скрипта ---")
print(f"Входной файл: {config.input_file}")
print(f"Режим: {config.mode}")

# Пример использования в логике
if config.mode == 'slow':
    print("Выбран медленный, но точный режим.")
else:
    print("Выбран быстрый режим.")

# Можно также записать результат в контекст для следующего скрипта
pysm_context.set("processing_mode_used", config.mode)

```

**Как это работает:**

*   **При запуске из PySM**: `ConfigResolver` увидит, что есть файл контекста. Он попытается найти переменные `input_file` и `mode` в контексте. Если они там есть, он их использует.
*   **При запуске из командной строки (`python dual_purpose_script.py --input-file data.csv`)**: `ConfigResolver` не найдет файла контекста. Он увидит, что `input-file` был передан через флаг, и возьмет это значение. Для `--mode` он не найдет флага и возьмет значение по умолчанию "fast".