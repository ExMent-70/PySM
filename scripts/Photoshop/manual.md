### **Руководство по использованию API PyScriptManager в пользовательских скриптах (Финальная Редакция)**

#### **Введение**

Данное руководство предназначено для разработчиков скриптов, которые будут выполняться в среде "Менеджера Python-скриптов" (PySM). Цель этого документа — подробно описать предоставляемый программный интерфейс (API), который позволяет скриптам взаимодействовать с окружением PySM для решения следующих задач:
*   Получение параметров из графического интерфейса.
*   Организация обмена данными между скриптами в рамках одного набора.
*   Работа со сложными метаданными документов Adobe Photoshop.
*   Отображение индикации прогресса выполнения в главном окне приложения.

Использование данного API позволяет абстрагироваться от деталей реализации и сосредоточиться на прикладной логике вашего скрипта.

---

#### **1. Основы взаимодействия: Определение среды выполнения**

**Проблема:** Любой скрипт требует отладки. Запуск скрипта каждый раз через графический интерфейс PySM может быть неэффективным. Необходимо обеспечить возможность запускать и отлаживать скрипт как в вашей интегрированной среде разработки (IDE), так и под управлением PySM, без внесения изменений в код.

**Решение:** API PySM спроектировано таким образом, что его ключевой пакет, `pysm_lib`, доступен для импорта только в том случае, если скрипт запущен менеджером PySM. Это позволяет использовать стандартный механизм обработки исключений Python для определения среды выполнения.

**Рекомендуемая практика:**
Используйте конструкцию `try...except ImportError` в начале вашего скрипта. Это позволит создать флаг `IS_MANAGED_RUN`, который можно использовать для условного выполнения кода, зависящего от API.

```python
# Эта переменная будет истинной только при запуске через PySM
IS_MANAGED_RUN = False

try:
    # Попытка импорта ключевых компонентов API
    from pysm_lib import pysm_context
    from pysm_lib.pysm_context import ConfigResolver
    IS_MANAGED_RUN = True
except ImportError:
    # Этот блок выполнится при прямом запуске скрипта,
    # когда пакет pysm_lib недоступен.
    # Создаем заглушки, чтобы избежать ошибок NameError далее по коду.
    pysm_context = None
    ConfigResolver = None
```
**Преимущество:** Такой подход обеспечивает универсальность вашего скрипта. Он сохраняет работоспособность в любой среде, а функциональность, специфичная для PySM, активируется автоматически при запуске через менеджер.

---

#### **2. Работа с параметрами запуска: `ConfigResolver`**

**Проблема:** Традиционная передача параметров через командную строку (`sys.argv`) неудобна для конечного пользователя. Стандартная библиотека `argparse` решает эту проблему, но требует запуска из консоли. Необходимо объединить удобство графической настройки с гибкостью командной строки.

**Решение:** PySM предоставляет класс `ConfigResolver`, который заменяет стандартный вызов `parser.parse_args()` и реализует многоуровневую систему получения параметров.

**Иерархия приоритетов получения значений:**
1.  **Аргументы командной строки:** Явно переданные флаги (например, `python my_script.py --threshold 0.8`). Имеют наивысший приоритет и переопределяют все остальные.
2.  **Переменные из Контекста Коллекции:** Значения, установленные пользователем в графическом интерфейсе "Паспорта коллекции".
3.  **Значения по умолчанию:** Значения, указанные в коде скрипта при определении аргумента (`default=...`).

**Практическое применение:**
Вы описываете аргументы с помощью `argparse`, как обычно, но для получения финальных значений используете `ConfigResolver`.

```python
import argparse

# 1. Описание аргументов с помощью стандартного argparse
parser = argparse.ArgumentParser(description="Описание скрипта.")
parser.add_argument("--input_path", type=str, help="Путь к входному файлу.")
parser.add_argument("--threshold", type=float, default=0.5, help="Порог отсечки.")
parser.add_argument("--modes", nargs='*', help="Список режимов обработки (принимает несколько значений).")

# 2. Создание экземпляра ConfigResolver
# Этот код должен выполняться только под управлением PySM
if IS_MANAGED_RUN:
    resolver = ConfigResolver(parser)
    
    # 3. Получение значений через методы резолвера
    input_path = resolver.get_path("input_path") # Для путей
    threshold = resolver.get("threshold")         # Для всех других типов
    modes = resolver.get("modes")                 # Корректно обработает nargs='*'
else:
    # Для автономного запуска используем стандартный argparse
    args = parser.parse_args()
    input_path = args.input_path
    threshold = args.threshold
    modes = args.modes
```
**Нюансы `ConfigResolver`:**
*   **`get_path(имя_аргумента)`:** Специализированный метод для путей. Он не только получает значение, но и преобразует его в абсолютный путь, решая проблему относительных путей.
*   **`get(имя_аргумента)`:** Универсальный метод для всех остальных типов данных (`str`, `int`, `float`, `bool`, `list`). Он корректно обрабатывает флаги (`action="store_true"`) и списки (`nargs='*'` или `nargs='+'`).

---

#### **3. Обмен данными между скриптами: Контекст Коллекции**

**Проблема:** Часто возникает задача передать результат работы одного скрипта (например, путь к созданному файлу или список обработанных элементов) на вход следующему скрипту в наборе. Использование промежуточных файлов для этой цели является ненадежным и неэлегантным решением.

**Решение:** PySM предоставляет централизованное хранилище — **Контекст Коллекции**. Это, по сути, словарь, который существует на протяжении всего выполнения одного набора скриптов. Все скрипты в наборе имеют доступ к этому общему хранилищу.

**3.1. Запись данных в контекст**
Для записи используются методы `.set()` (для одной переменной) и `.update()` (для нескольких). API автоматически определяет и сохраняет тип данных.

```python
from pysm_lib import pysm_context

# Запись одной переменной
pysm_context.set("processed_files_count", 15) # Тип 'int' будет определен автоматически

# Запись нескольких переменных из словаря
report = {
    "output_archive": "/reports/report.zip",
    "errors_detected": False,
    "failed_files": []
}
pysm_context.update(report)
```

**3.2. Чтение данных из контекста**
Основным методом для чтения является `.get_structured()`. Он возвращает данные в их исходном виде (числа, строки, списки, словари).

```python
# Чтение простого значения с указанием значения по умолчанию
user_name = pysm_context.get_structured("user_name", default="Гость")

# Чтение списка
allowed_extensions = pysm_context.get_structured("allowed_extensions", default=[])
if "png" in allowed_extensions:
    print("Обработка PNG разрешена.")
```

**3.3. Доступ к вложенным данным**
Метод `.get_structured()` поддерживает "точечную нотацию" для удобного доступа к элементам вложенных словарей, что избавляет от громоздких проверок.

```python
# Предположим, в контексте есть переменная 'config' со значением:
# {"database": {"host": "localhost", "port": 5432}}

# Вместо такого кода:
# db_config = pysm_context.get_structured("config", {})
# if db_config and "database" in db_config:
#     host = db_config["database"].get("host")

# Можно написать так:
host = pysm_context.get_structured("config.database.host") # вернет 'localhost'
```

**3.4. Удаление данных**
Метод `.remove()` позволяет удалять переменные из контекста.

```python
pysm_context.remove("temp_variable") # Удалить одну переменную
pysm_context.remove(["temp_var_1", "temp_var_2"]) # Удалить список переменных
pysm_context.remove() # Удалить ВСЕ переменные (кроме системных)
```

---

#### **4. Работа с метаданными документов (Photoshop)**

**Проблема:** Извлечение XMP-метаданных из графических файлов (PSD, JPG, TIFF) — это нетривиальная задача, требующая взаимодействия с COM-интерфейсом Adobe Photoshop и парсинга XML.

**Решение:** API `pysm_context` предоставляет высокоуровневый метод `get_document_metadata`, который инкапсулирует всю сложность этой операции.

**4.1. Концепция: Схема данных `FIELD_MAP`**
Метод `get_document_metadata` работает на основе внутренней схемы — словаря `FIELD_MAP`. Эта схема сообщает API, как интерпретировать каждое XMP-поле, извлекая данные в нужный формат Python.

```python
# Полная структура FIELD_MAP, используемая внутри API:
FIELD_MAP = {
    # Поля типа 'simple' сохраняются как строки (str)
    "CaptionWriter": ("...", 'simple'), "Headline": ("...", 'simple'),
    "City": ("...", 'simple'), "State": ("...", 'simple'),
    "Country": ("...", 'simple'), "Source": ("...", 'simple'),
    "Instructions": ("...", 'simple'), "Category": ("...", 'simple'),
    "TransmissionReference": ("...", 'simple'), "Credit": ("...", 'simple'),
    "Location": ("...", 'simple'), "IntellectualGenre": ("...", 'simple'),
    "Label": ("...", 'simple'), "Rating": ("...", 'simple'),
    "Personality": ("...", 'simple'), "Description": ("...", 'simple'),
    "Copyright": ("...", 'simple'),

    # Поля типа 'array' сохраняются как списки строк (List[str])
    "SupplementalCategories": ("...", 'array'), "Scene": ("...", 'array'),
    "Creator": ("...", 'array'), "Keywords": ("...", 'array'),

    # Поля типа 'structure' содержат данные "ключ:значение"
    # и сохраняются как словари (Dict[str, str])
    "SubjectCode": ("...", 'structure'),
}
```
**Важно:** Вам не нужно изменять этот словарь. Достаточно понимать, что тип, указанный в нем, определяет формат данных, которые вы получите в своем скрипте.

**4.2. Замечание о зависимости от Adobe Photoshop**
Для работы метода `get_document_metadata` **требуется установленное и запущенное приложение Adobe Photoshop**.
*   **Если Photoshop не установлен или не запущен**, вызов этого метода сгенерирует исключение `RuntimeError` с подробным описанием проблемы. Это не приведет к аварийному завершению работы всего менеджера, а лишь прервет выполнение вашего скрипта с информативным сообщением.
*   Все остальные функции API (`get_structured`, `set`, `ConfigResolver` и т.д.) **не зависят от Photoshop** и будут работать в любом случае.

**4.3. Извлечение и чтение метаданных**
```python
try:
    # 1. Вызываем метод, чтобы извлечь все метаданные и записать их в контекст
    pysm_context.get_document_metadata(
        doc_path="/path/to/photo.jpg",
        fields="__all__", # Ключевое слово для извлечения всех полей из FIELD_MAP
        clear_before_write=True # Рекомендуется для очистки старых данных
    )

    # 2. Теперь данные доступны для чтения через get_structured()
    headline = pysm_context.get_structured("psd_meta_Headline") # -> str
    keywords = pysm_context.get_structured("psd_meta_Keywords") # -> list
    person_name = pysm_context.get_structured("psd_meta_SubjectCode.F0_person") # -> str (вложенный доступ)

except RuntimeError as e:
    print(f"Ошибка работы с Photoshop: {e}")
```

---

#### **5. Отображение прогресса выполнения (`tqdm`)**

**Проблема:** Длительные операции (например, обработка сотен файлов) должны визуализировать свой прогресс, чтобы пользователь понимал, что программа работает, а не зависла.

**Решение:** PySM предлагает элегантную интеграцию с популярной библиотекой `tqdm`. Вам не нужно изучать новый API для прогресс-баров.

**Как это работает:** При запуске скрипта через менеджер, PySM "на лету" подменяет стандартную `tqdm` своей реализацией, которая перенаправляет все вызовы на прогресс-бар в графическом интерфейсе.

**Как это использовать:**
Просто пишите код с `tqdm`, как вы делали это всегда.
```python
from pysm_lib import tqdm
import time

# Пример итерации по списку
file_list = ["file1.jpg", "file2.jpg", "file3.jpg"]
for filename in tqdm(file_list, desc="Обработка изображений"):
    time.sleep(1) # Имитация работы

# Пример ручного управления
with tqdm(total=100, desc="Анализ данных") as pbar:
    for i in range(100):
        time.sleep(0.1)
        pbar.update(1)
```
**Нюансы:**
*   **Текстовый вывод:** Для вывода логов внутри цикла `tqdm` используйте `tqdm.write("Сообщение")`. Это предотвратит "ломание" отображения прогресс-бара.
*   **Универсальность:** Если вы запустите этот же скрипт напрямую в консоли, он будет работать как обычно, используя оригинальную библиотеку `tqdm` (если она установлена в вашем Python-окружении).